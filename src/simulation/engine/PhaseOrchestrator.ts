/**
 * Phase Orchestrator - Phase 4
 *
 * Manages execution of simulation phases in correct order.
 * Each phase is a self-contained unit of work that can be tested independently.
 */

import { GameState, GameEvent } from '@/types/game';

/**
 * Random number generator function
 */
export type RNGFunction = () => number;

/**
 * Result of executing a phase
 */
export interface PhaseResult {
  /**
   * Events generated by this phase
   */
  events: GameEvent[];

  /**
   * Optional state replacement (for phases that return new state)
   */
  newState?: GameState;

  /**
   * Optional metadata about phase execution
   */
  metadata?: Record<string, any>;
}

/**
 * Represents a single simulation phase
 */
export interface SimulationPhase {
  /**
   * Unique identifier for this phase
   */
  readonly id: string;

  /**
   * Human-readable name for debugging
   */
  readonly name: string;

  /**
   * Execution order (lower numbers run first)
   * Use decimals for fine-grained ordering (e.g., 0.5, 1.0, 1.5)
   */
  readonly order: number;

  /**
   * Execute this phase
   *
   * @param state - Current game state (may be mutated)
   * @param rng - Random number generator function
   * @param context - Optional context from previous phases
   * @returns Phase result with events and optional new state
   */
  execute(state: GameState, rng: RNGFunction, context?: PhaseContext): PhaseResult;
}

/**
 * Context shared between phases during a single step
 */
export interface PhaseContext {
  /**
   * Current month being simulated
   */
  month: number;

  /**
   * Logger instance (if available)
   */
  logger?: any;

  /**
   * Arbitrary data that phases can use to communicate
   */
  data: Map<string, any>;
}

/**
 * Orchestrates simulation phases in correct order
 */
export class PhaseOrchestrator {
  private phases: SimulationPhase[] = [];
  private sorted: boolean = false;

  /**
   * Register a phase
   */
  registerPhase(phase: SimulationPhase): void {
    this.phases.push(phase);
    this.sorted = false; // Mark as needing re-sort
  }

  /**
   * Register multiple phases at once
   */
  registerPhases(phases: SimulationPhase[]): void {
    this.phases.push(...phases);
    this.sorted = false;
  }

  /**
   * Execute all phases in order
   *
   * @param state - Game state (will be mutated)
   * @param rng - Random number generator
   * @param context - Optional context (created if not provided)
   * @returns All events generated by phases
   */
  executeAll(state: GameState, rng: RNGFunction, context?: PhaseContext): GameEvent[] {
    // Ensure phases are sorted by order
    if (!this.sorted) {
      this.sortPhases();
    }

    // Create context if not provided
    const ctx: PhaseContext = context || {
      month: state.currentMonth,
      data: new Map()
    };

    const allEvents: GameEvent[] = [];

    for (const phase of this.phases) {
      try {
        const result = phase.execute(state, rng, ctx);

        // Collect events
        if (result.events && result.events.length > 0) {
          allEvents.push(...result.events);
        }

        // Handle state replacement (some phases return new state)
        if (result.newState) {
          // Copy properties from new state to current state
          Object.assign(state, result.newState);
        }

        // Store metadata in context for later phases
        if (result.metadata) {
          ctx.data.set(phase.id, result.metadata);
        }
      } catch (error) {
        console.error(`\n❌ ERROR in phase "${phase.name}" (${phase.id}):`, error);
        // Continue with other phases to avoid complete simulation failure
        // This matches current engine behavior (some phases have try/catch)
      }
    }

    return allEvents;
  }

  /**
   * Get execution order (for debugging/documentation)
   */
  getExecutionOrder(): string[] {
    if (!this.sorted) {
      this.sortPhases();
    }
    return this.phases.map(p => `[${p.order}] ${p.name} (${p.id})`);
  }

  /**
   * Get phase count
   */
  getPhaseCount(): number {
    return this.phases.length;
  }

  /**
   * Get phase by ID
   */
  getPhase(id: string): SimulationPhase | undefined {
    return this.phases.find(p => p.id === id);
  }

  /**
   * Clear all registered phases (useful for testing)
   */
  clear(): void {
    this.phases = [];
    this.sorted = false;
  }

  /**
   * Sort phases by order
   */
  private sortPhases(): void {
    this.phases.sort((a, b) => {
      // Primary sort: by order
      if (a.order !== b.order) {
        return a.order - b.order;
      }
      // Secondary sort: by name (for stability)
      return a.name.localeCompare(b.name);
    });
    this.sorted = true;
  }
}
